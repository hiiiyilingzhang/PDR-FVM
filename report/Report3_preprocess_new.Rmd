---
title: "Report3_preprocess_new"
author: "zhangyl"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
  self contained: true
  thumbnails: true
  lightbox: true
  gallery: false
  highlight: tango
---

```{r include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
	message = FALSE,
	warning = FALSE,
	fig.align = "center",
  fig.width = 8
)
```

# 1. Initialize Data
```{r}
library(Seurat)
library(dplyr)
library(ggplot2)
```

## 1.1 Read in and Initialize Seurat Obejct

**Singleron**:  
```{r eval=FALSE}
raw.p1ERM <- read.table("data/rawMatix/patient_1/PDR-ERM-0426_matrix.tsv",header = T) %>% CreateSeuratObject(project = "p1-ERM")
raw.p1Blood <- read.table("data/rawMatix/patient_1/PDR-Blood-0426_matrix.tsv", header = T) %>% CreateSeuratObject(project = "p1-Blood")

raw.p2ERM <- read.table("data/rawMatix/patient_2/PDR-ERM_matrix.tsv", header = T) %>% CreateSeuratObject(project = "p2-ERM")
raw.p2Blood <- read.table("data/rawMatix/patient_2/PDR-Blood_matrix.tsv", header = T) %>% CreateSeuratObject(project = "p2-Blood")

raw.p3ERM <- read.table("data/rawMatix/patient_3/PDR-ERM-0609_matrix.tsv.gz",header = T) %>% CreateSeuratObject(project = "p3-ERM")
raw.p3Blood <- read.table("data/rawMatix/patient_3/PDR-blood-0609_matrix.tsv.gz",header = T) %>% CreateSeuratObject(project = "p3-Blood")

raw.p4ERM <- read.table("data/rawMatix/patient_4/PDR-ERM-210630_matrix.tsv.gz",header = T) %>% CreateSeuratObject(project = "p4-ERM")
raw.p4Blood <- read.table("data/rawMatix/patient_4/PDR-B-210630_matrix.tsv.gz",header = T) %>% CreateSeuratObject(project = "p4-Blood")

raw.ctl1.Singleron <- read.table("data/rawMatix/control_PBMC/mid-aged/DZ0804_matrix.tsv.gz",header = T) %>% CreateSeuratObject(project = "p4-ERM")
```

**10X**: 
```{r eval=FALSE}
raw.ctl2.10X <- Read10X(data.dir = "data/rawMatix/control_PBMC/mid-aged/GSM5335490_C1/C1/") %>% CreateSeuratObject(project = "10X_ctr2")

raw.ctl3.10X <- Read10X(data.dir = "data/rawMatix/control_PBMC/mid-aged/GSM5335491_C2/C2/") %>% CreateSeuratObject(project = "10X_ctr3")

raw.ctl4.10X <- Read10X(data.dir = "data/rawMatix/control_PBMC/young/GSM4905216_YYZ/YYZ/") %>% CreateSeuratObject(project = "10X_ctr4")

raw.ctl5.10X <- Read10X(data.dir = "data/rawMatix/control_PBMC/young/GSM4905217_YTK/YTK/") %>% CreateSeuratObject(project = "10X_ctr5")

raw.ctl6.10X <- Read10X(data.dir = "data/rawMatix/control_PBMC/young/GSM4954813_C-1/") %>% CreateSeuratObject(project = "10X_ctr6")
```

## 1.2 Merge data

**Singleron**: 
```{r eval=FALSE}
raw.Singleron <- merge(x = raw.p1ERM, y = c(raw.p1Blood, raw.p2ERM, raw.p2Blood,raw.p3ERM, raw.p3Blood, raw.p4ERM, raw.p4Blood, raw.ctl1.Singleron))
```


**10X**: 
```{r eval=FALSE}
raw.10X <- merge(x = raw.ctl2.10X, y = c(raw.ctl3.10X,raw.ctl4.10X, raw.ctl5.10X, raw.ctl6.10X))
```

>Some cell names are duplicated across objects provided. Renaming to enforce unique cell names.  
>Loss of specific data?  

## 1.3 Check Data

```{r include=FALSE}
raw.Singleron <- readRDS("../data/rawSeurat/rawSingleron.RDS")
raw.10X <- readRDS("../data/rawSeurat/raw10X.RDS")
```

```{r}
raw.Singleron@assays$RNA[1:5,1:5]
```

```{r}
raw.Singleron@meta.data[1:5,]
```

```{r}
raw.Singleron@meta.data %>% 
  	ggplot(aes(x=orig.ident, fill=orig.ident)) + 
  	geom_bar() +
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold")) +
  	ggtitle("NCells")
```

```{r}
raw.10X@meta.data %>% 
  	ggplot(aes(x=orig.ident, fill=orig.ident)) + 
  	geom_bar() +
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold")) +
  	ggtitle("NCells")
```

# 2. QC--Singleron
## 2.1 Data examining
cell number:    
```{r}
dim(raw.Singleron)
```

Counts per cell:    
```{r}
counts_per_cell <- Matrix::colSums(raw.Singleron)
hist(log10(counts_per_cell+1),main='counts per cell',col='Thistle')
```

Genes per cell:    
```{r}
genes_per_cell <- Matrix::colSums(raw.Singleron@assays$RNA@counts > 0)
hist(log10(genes_per_cell+1), main='genes per cell', col='Thistle')
```

## 2.2 Remove Doublets

* [DoubletDecon](https://github.com/EDePasquale/DoubletDecon)  
Fail to install

* [DoubletFinder](https://github.com/chris-mcginnis-ucsf/DoubletFinder)

```{r}
library(DoubletFinder)
library(patchwork)
library(ggraph)
library(clustree)
```

### 2.2.1 Pre-process Seurat object

```{r message=FALSE, warning=FALSE}
raw.Singleron <- SCTransform(raw.Singleron, verbose = F)
raw.Singleron <- RunPCA(raw.Singleron, npcs = 30, verbose = F)
ElbowPlot(raw.Singleron,ndims = 30)
```

```{r}
# Set dim 1:20
pc.num=1:25
```

```{r}
raw.Singleron <- RunUMAP(raw.Singleron, dims=pc.num,verbose = F)
raw.Singleron <- FindNeighbors(raw.Singleron, reduction = "pca", dims = pc.num)
```

```{r fig.height=8}
checkRes <- FindClusters(object = raw.Singleron, resolution = c(seq(.1,1.6,.2)), verbose = F)
clustree(checkRes@meta.data,prefix = "SCT_snn_res.")
```

```{r}
raw.Singleron <- FindClusters(raw.Singleron, resolution = 0.7)
```

### 2.2.2 pK Identification

```{r eval=FALSE}
# Optimize the parameters
sweep.res.list <- paramSweep_v3(raw.Singleron, PCs = pc.num, sct = T)
# Use log transform
sweep.stats <- summarizeSweep(sweep.res.list, GT = F)
```

```{r include=FALSE}
load("../data/tmp.data/sweepStats.RData")
```

```{r}
# Show the best parameter
bcmvn <- find.pK(sweep.stats)
```

```{r}
# Extract the best pK
pK_bcmvn <- bcmvn$pK[which.max(bcmvn$BCmetric)] %>% as.character() %>% as.numeric()
pK_bcmvn
```

### 2.2.3 Homotypic Doublet Proportion Estimate

>doublet rate: https://singleronbio.com/product/?type=detail&id=8

```{r}
# Estimate the percentage of homotypic doublets
homotypic.prop <- modelHomotypic(raw.Singleron$seurat_clusters)

DoubletRate = 0.0268
nExp_poi <- round(DoubletRate*ncol(raw.Singleron)) 
# Adjust for homotypic doublets
nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
```

### 2.2.4 Run DoubletFinder

```{r eval=FALSE}
raw.Singleron <- doubletFinder_v3(raw.Singleron, PCs = pc.num, pN = 0.25, pK = pK_bcmvn, 
                             nExp = nExp_poi.adj, reuse.pANN = F, sct = T)
```

```{r include=FALSE, eval=TRUE}
raw.Singleron <- readRDS("../data/SeuratObj/merged.RDS")
```

```{r}
# Present the res, classification info is saved in meta.data
DF.name <- colnames(raw.Singleron@meta.data)[grepl("DF.classification", colnames(raw.Singleron@meta.data))]
# Visualization
cowplot::plot_grid(ncol = 2, DimPlot(raw.Singleron, group.by = "orig.ident") + NoAxes(), 
                   DimPlot(raw.Singleron, group.by = DF.name) + NoAxes())
```


```{r}
DF.name <- colnames(raw.Singleron@meta.data)[grepl("DF.classification", colnames(raw.Singleron@meta.data))]
raw.Singleron.singlet <- raw.Singleron[, raw.Singleron@meta.data[, DF.name] == "Singlet"]
raw.Singleron.singlet
```


## 2.3 Calculate QC
### 2.3.1 Generating quality metrics

**mitochondrial ratio:**
```{r}
raw.Singleron.singlet[["percent.mt"]] <- PercentageFeatureSet(object = raw.Singleron.singlet, pattern = "^MT-", assay = "RNA")
raw.Singleron.singlet$percent.mt <- raw.Singleron.singlet@meta.data$percent.mt / 100
```

**ribosome ratio:** 
```{r}
raw.Singleron.singlet[["percent.ribo"]] <- PercentageFeatureSet(object = raw.Singleron.singlet, pattern = "^RP[SL]", assay = "RNA")
raw.Singleron.singlet$percent.ribo <- raw.Singleron.singlet@meta.data$percent.ribo / 100
```

**hemoglobin ratio:**
```{r}
raw.Singleron.singlet[["percent.hb"]] <- PercentageFeatureSet(object = raw.Singleron.singlet, pattern = "^HB[^(P)]", assay = "RNA")
raw.Singleron.singlet$percent.ribo <- raw.Singleron.singlet@meta.data$percent.ribo / 100
```

**number of genes detected per UMI:**    
represent the complexity of our dataset (more genes detected per UMI, more complex our data)
```{r}
raw.Singleron.singlet$log10GenesPerUMI <- log10(raw.Singleron.singlet$nFeature_RNA) / log10(raw.Singleron.singlet$nCount_RNA)
```

### 2.3.2 Assessing the quality metrics:   

**UMI counts (transcripts) per cell**  
The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply.    

* Visualize the number UMIs/transcripts per cell    
```{r}
raw.Singleron.singlet@meta.data %>% 
  	ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	ylab("Cell density") +
  	geom_vline(xintercept = 500)
```

**Genes detected per cell**  
For high quality data, the proportional histogram should contain a single large peak that represents cells that were encapsulated. 

* Visualize the distribution of genes detected per cell via histogram
```{r}
raw.Singleron.singlet@meta.data %>% 
  	ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + 
  	geom_density(alpha = 0.2) + 
  	theme_classic() +
  	scale_x_log10() + 
  	geom_vline(xintercept = 300)
```


**UMIs vs. genes detected**  
Cells that are poor quality are likely to have low genes and UMIs per cell, and correspond to the data points in the bottom left quadrant of the plot. Good cells will generally exhibit both higher number of genes per cell and higher numbers of UMIs. Cells have a high number of UMIs but only a few number of genes could be dying cells, but also could represent a population of a low complexity celltype (i.e red blood cells).  


Mitochondrial read fractions are only high in particularly low count cells with few detected genes. This could be indicative of damaged/dying cells whose cytoplasmic mRNA has leaked out through a broken membrane, and thus, only mRNA located in the mitochondria is still conserved.   

* Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs
```{r}
raw.Singleron.singlet@meta.data %>% 
  	ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + 
  	geom_point() + 
	scale_colour_gradient(low = "gray90", high = "black") +
  	stat_smooth(method=lm) +
  	scale_x_log10() + 
  	scale_y_log10() + 
  	theme_classic() +
  	geom_vline(xintercept = 500) +
  	geom_hline(yintercept = 250) +
  	facet_wrap(~orig.ident)
```

**Complexity**
Outlier cells in these samples might be cells that have a less complex RNA species than other cells. Sometimes we can detect contamination with low complexity cell types like red blood cells via this metric. Generally, we expect the novelty score to be above 0.80.

* Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI
```{r}
raw.Singleron.singlet@meta.data %>%
  	ggplot(aes(x=log10GenesPerUMI, color = orig.ident, fill=orig.ident)) +
  	geom_density(alpha = 0.2) +
  	theme_classic() +
  	geom_vline(xintercept = 0.8)
```

**Mitochondrial counts ratio**
This metric can identify whether there is a large amount of mitochondrial contamination from dead or dying cells.

* Visualize the distribution of mitochondrial gene expression detected per cell
```{r}
raw.Singleron.singlet@meta.data %>% 
  	ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	geom_vline(xintercept = 0.2)
```


**Ribosome counts ratio**
This metric can identify whether there is a large amount of ribosome contamination from dead or dying cells.

* Visualize the distribution of ribosome gene expression detected per cell
```{r}
raw.Singleron.singlet@meta.data %>% 
  	ggplot(aes(color=orig.ident, x=percent.ribo, fill=orig.ident)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	geom_vline(xintercept = 0.01)
```


**Hemoglobin counts ratio**
This metric can identify whether there is a large amount of hemoglobin contamination from red blood cell leak.

* Visualize the distribution of mitochondrial gene expression detected per cell
```{r}
raw.Singleron.singlet@meta.data %>% 
  	ggplot(aes(color=orig.ident, x=percent.hb, fill=orig.ident)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	geom_vline(xintercept = 0.25)
```


## 2.4 Filtering
### 2.4.1 Cell-level filtering
* nCount > 500  
* nFeature > 250  
* log10GenesPerUMI > 0.8  
* percent.mt < 0.2  
* percent.ribo < 0.01  
* percent.hb < 0.25  

```{r}
filteredData <- subset(x = raw.Singleron.singlet, 
                         subset= (nCount_RNA >= 500) & 
                           (nFeature_RNA >= 250) & 
                           (log10GenesPerUMI > 0.80) & 
                           (percent.mt < 0.20) & 
                           (percent.ribo < 0.01) & 
                           (percent.hb < 0.25))
```

### 2.4.2 Gene-level filtering
```{r eval=FALSE}
par(mar = c(4, 8, 2, 1))
C <- filteredData@assays$RNA@counts
C <- Matrix::t(Matrix::t(C)/Matrix::colSums(C)) * 100
most_expressed <- order(apply(C, 1, median), decreasing = T)[20:1]
boxplot(as.matrix(t(C[most_expressed,])), cex = 0.1, las = 1, xlab = "% total count per cell", col = (scales::hue_pal())(20)[20:1], horizontal = TRUE)
```

First we will remove genes that have zero expression in all cells. Additionally, we will perform some filtering by prevalence. If a gene is only expressed in a handful of cells, it is not particularly meaningful. For our data we choose to **keep only genes which are expressed in 5 or more cells**.

```{r}
# Extract counts
counts <- GetAssayData(object = filteredData, slot = "counts",assay = "RNA")

# Output a logical vector for every gene on whether the more than zero counts per cell
nonzero <- counts > 0

# Sums all TRUE values and returns TRUE if more than 5 TRUE values per gene
keep_genes <- Matrix::rowSums(nonzero) >= 5

# Only keeping those genes expressed in more than 10 cells
filtered_counts <- counts[keep_genes, ]

# Reassign to filtered Seurat object
filteredData2 <- CreateSeuratObject(filtered_counts, meta.data = filteredData@meta.data)
filteredData2
```

